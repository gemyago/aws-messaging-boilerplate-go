
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gemyago/aws-messaging-boilerplate-go/cmd/server/main.go (57.1%)</option>
				
				<option value="file1">github.com/gemyago/aws-messaging-boilerplate-go/cmd/server/root.go (95.7%)</option>
				
				<option value="file2">github.com/gemyago/aws-messaging-boilerplate-go/cmd/server/start.go (90.5%)</option>
				
				<option value="file3">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/http.go (60.0%)</option>
				
				<option value="file4">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/middleware/chain.go (100.0%)</option>
				
				<option value="file5">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/middleware/recover.go (100.0%)</option>
				
				<option value="file6">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/middleware/tracing.go (100.0%)</option>
				
				<option value="file7">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/server/handler.go (100.0%)</option>
				
				<option value="file8">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/server/register.go (100.0%)</option>
				
				<option value="file9">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/server/router.go (100.0%)</option>
				
				<option value="file10">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/server/server.go (100.0%)</option>
				
				<option value="file11">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1controllers/messages.go (100.0%)</option>
				
				<option value="file12">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1controllers/mock_dummy_messages_commands.go (39.5%)</option>
				
				<option value="file13">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1controllers/register.go (100.0%)</option>
				
				<option value="file14">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/handlers/handlers.go (33.6%)</option>
				
				<option value="file15">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/handlers/messages_controller.go (58.1%)</option>
				
				<option value="file16">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/handlers/messages_params.go (46.2%)</option>
				
				<option value="file17">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/internal/dummy_message_validation.go (100.0%)</option>
				
				<option value="file18">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/internal/error_validation.go (0.0%)</option>
				
				<option value="file19">github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/internal/validators.go (13.3%)</option>
				
				<option value="file20">github.com/gemyago/aws-messaging-boilerplate-go/internal/app/commands.go (100.0%)</option>
				
				<option value="file21">github.com/gemyago/aws-messaging-boilerplate-go/internal/app/register.go (100.0%)</option>
				
				<option value="file22">github.com/gemyago/aws-messaging-boilerplate-go/internal/config/load.go (95.8%)</option>
				
				<option value="file23">github.com/gemyago/aws-messaging-boilerplate-go/internal/config/provide.go (100.0%)</option>
				
				<option value="file24">github.com/gemyago/aws-messaging-boilerplate-go/internal/config/testing.go (100.0%)</option>
				
				<option value="file25">github.com/gemyago/aws-messaging-boilerplate-go/internal/di/dig.go (94.1%)</option>
				
				<option value="file26">github.com/gemyago/aws-messaging-boilerplate-go/internal/diag/attributes.go (100.0%)</option>
				
				<option value="file27">github.com/gemyago/aws-messaging-boilerplate-go/internal/diag/mock_slog_handler.go (34.7%)</option>
				
				<option value="file28">github.com/gemyago/aws-messaging-boilerplate-go/internal/diag/slog.go (93.1%)</option>
				
				<option value="file29">github.com/gemyago/aws-messaging-boilerplate-go/internal/diag/testing.go (75.0%)</option>
				
				<option value="file30">github.com/gemyago/aws-messaging-boilerplate-go/internal/queues/mock_message_poller.go (54.8%)</option>
				
				<option value="file31">github.com/gemyago/aws-messaging-boilerplate-go/internal/queues/register.go (100.0%)</option>
				
				<option value="file32">github.com/gemyago/aws-messaging-boilerplate-go/internal/queues/start.go (100.0%)</option>
				
				<option value="file33">github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi/aws.go (100.0%)</option>
				
				<option value="file34">github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi/event_bus_message_sender.go (90.9%)</option>
				
				<option value="file35">github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi/mock_message_sender.go (68.2%)</option>
				
				<option value="file36">github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi/register.go (100.0%)</option>
				
				<option value="file37">github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi/sns_message_sender.go (90.0%)</option>
				
				<option value="file38">github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi/sqs_poller.go (91.5%)</option>
				
				<option value="file39">github.com/gemyago/aws-messaging-boilerplate-go/internal/services/register.go (100.0%)</option>
				
				<option value="file40">github.com/gemyago/aws-messaging-boilerplate-go/internal/services/shutdown.go (95.8%)</option>
				
				<option value="file41">github.com/gemyago/aws-messaging-boilerplate-go/internal/services/testing.go (12.5%)</option>
				
				<option value="file42">github.com/gemyago/aws-messaging-boilerplate-go/internal/services/time.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="3">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newStartServerCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/app"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/config"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/di"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/diag"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/services"
        "github.com/samber/lo"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        logsOutputFile := ""

        cmd := &amp;cobra.Command{
                Use:   "server",
                Short: "Command to start the server",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().Bool(
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringP(
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cfg := config.New()
        lo.Must0(cfg.BindPFlags(cmd.PersistentFlags()))
        cmd.PersistentPreRunE = func(cmd *cobra.Command, _ []string) error </span><span class="cov10" title="3">{
                rootCtx := cmd.Context()
                err := config.Load(cfg, config.NewLoadOpts().WithEnv(cfg.GetString("env")))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="2">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov1" title="1">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(cfg.GetBool("jsonLogs")).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),

                        // app layer
                        app.Register(container),

                        // services
                        services.Register(rootCtx, container),

                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),
                        ),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to inject dependencies: %w", err)
                }</span>

                <span class="cov1" title="1">return nil</span>
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "errors"
        "log/slog"
        "os/signal"
        "time"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/server"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/diag"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/queues"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/services"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type startServerParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        HTTPServer *server.HTTPServer
        QueuesDeps queues.Deps

        *services.ShutdownHooks

        noop bool
}

func startServer(params startServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        httpServer := params.HTTPServer
        rootCtx := context.Background()

        shutdown := func() error </span><span class="cov1" title="1">{
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()

                err := params.ShutdownHooks.PerformShutdown(rootCtx)
                if err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Failed to shut down gracefully", diag.ErrAttr(err))
                }</span>

                <span class="cov1" title="1">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )
                return err</span>
        }

        <span class="cov1" title="1">signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        const startedComponents = 2
        startupErrors := make(chan error, startedComponents)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting http server")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- httpServer.Start(signalCtx)</span>
        }()
        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting polling queues")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- queues.StartPolling(signalCtx, params.QueuesDeps)</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1">
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server startup failed", "err", startupErr)
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"></span> // coverage-ignore
                // We will attempt to shut down in both cases
                // so doing it once on a next line
        }
        <span class="cov1" title="1">return errors.Join(startupErr, shutdown())</span>
}

func newStartServerCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "start",
                Short: "Command to start server",
        }
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Do not start. Just setup deps and exit. Useful for testing if setup is all working.",
        )
        cmd.PreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return errors.Join(
                        server.Register(container),
                        http.Register(container),
                        queues.Register(container),
                )
        }</span>
        <span class="cov10" title="3">cmd.RunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(params startServerParams) error </span><span class="cov1" title="1">{
                        params.noop = noop
                        return startServer(params)
                }</span>)
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package http

import (
        "errors"
        "log/slog"
        "net/http"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/server"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1controllers"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/handlers"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/di"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/diag"
        "go.uber.org/dig"
)

// Use apigen to generate v1routes
//go:generate apigen ./v1schemas/api.yaml ./v1routes --verbose

type V1RoutesAppDeps struct {
        dig.In

        RootLogger *slog.Logger

        Router *server.MuxRouterAdapter
}

func NewV1RoutesApp(deps V1RoutesAppDeps) *handlers.HTTPApp <span class="cov8" title="1">{ // coverage-ignore // Little value in testing wireup code.
        logger := deps.RootLogger.WithGroup("http.v1routes")
        return handlers.NewHTTPApp(deps.Router,
                handlers.WithLogger(logger),
                handlers.WithActionErrorHandler(func(r *http.Request, w http.ResponseWriter, err error) </span><span class="cov0" title="0">{
                        logger.ErrorContext(r.Context(), "Failed to process request", diag.ErrAttr(err))
                        http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                }</span>),
        )
}

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return errors.Join(
                v1controllers.Register(container),
                di.ProvideAll(container,
                        NewV1RoutesApp,
                        server.MakeHandlersGroupFactory(handlers.RegisterMessagesRoutes),
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import "net/http"

type Middleware func(http.Handler) http.Handler

func Chain(middlewares ...Middleware) func(http.Handler) http.Handler <span class="cov4" title="2">{
        return func(h http.Handler) http.Handler </span><span class="cov4" title="2">{
                for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov10" title="6">{
                        h = middlewares[i](h)
                }</span>
                <span class="cov4" title="2">return h</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "errors"
        "log/slog"
        "net/http"
        "runtime/debug"
)

// NewRecovererMiddleware creates a middleware that will handle panics
// log them and respond with 500 to client. This should be the last in a chain.
func NewRecovererMiddleware(rootLogger *slog.Logger) Middleware <span class="cov10" title="4">{
        return func(next http.Handler) http.Handler </span><span class="cov10" title="4">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="3">{
                        defer func() </span><span class="cov8" title="3">{
                                if rvr := recover(); rvr != nil </span><span class="cov5" title="2">{
                                        if err, ok := rvr.(error); ok &amp;&amp; errors.Is(err, http.ErrAbortHandler) </span><span class="cov1" title="1">{
                                                rootLogger.InfoContext(r.Context(), "Request aborted")
                                                return
                                        }</span>
                                        <span class="cov1" title="1">rootLogger.ErrorContext(
                                                r.Context(),
                                                "Unhandled panic",
                                                slog.Any("panic", rvr),
                                                slog.String("stack", string(debug.Stack())),
                                        )
                                        // TODO: Do not write header if already written
                                        w.WriteHeader(http.StatusInternalServerError)</span>
                                }
                        }()

                        <span class="cov8" title="3">next.ServeHTTP(w, r)</span>
                }

                <span class="cov10" title="4">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "log/slog"
        "net/http"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/diag"
        "github.com/gofrs/uuid/v5"
)

type TracingMiddlewareCfg struct {
        generateUUID func() string
}

func NewTracingMiddlewareCfg() *TracingMiddlewareCfg <span class="cov10" title="3">{
        return &amp;TracingMiddlewareCfg{
                generateUUID: func() string </span><span class="cov1" title="1">{
                        return uuid.Must(uuid.NewV4()).String()
                }</span>,
        }
}

func NewTracingMiddleware(cfg *TracingMiddlewareCfg) Middleware <span class="cov10" title="3">{
        generateUUID := cfg.generateUUID
        return func(next http.Handler) http.Handler </span><span class="cov10" title="3">{
                return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov6" title="2">{
                        correlationID := req.Header.Get("x-correlation-id")
                        if correlationID == "" </span><span class="cov1" title="1">{
                                correlationID = generateUUID()
                        }</span>
                        <span class="cov6" title="2">logAttributes := diag.GetLogAttributesFromContext(req.Context())
                        logAttributes.CorrelationID = slog.StringValue(correlationID)
                        nextCtx := diag.SetLogAttributesToContext(req.Context(), logAttributes)
                        next.ServeHTTP(w, req.WithContext(nextCtx))</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package server

import (
        "log/slog"
        "net/http"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/middleware"
        sloghttp "github.com/samber/slog-http"
        "go.uber.org/dig"
)

type RootHandlerDeps struct {
        dig.In

        RootLogger *slog.Logger
        Groups     []RegisterHandlersFunc `group:"server"`
        *MuxRouterAdapter
}

func NewRootHandler(deps RootHandlerDeps) http.Handler <span class="cov8" title="1">{
        for _, grp := range deps.Groups </span><span class="cov8" title="1">{
                grp()
        }</span>

        // Router wire-up
        <span class="cov8" title="1">chain := middleware.Chain(
                middleware.NewTracingMiddleware(middleware.NewTracingMiddlewareCfg()),
                sloghttp.NewWithConfig(deps.RootLogger, sloghttp.Config{
                        DefaultLevel:     slog.LevelInfo,
                        ClientErrorLevel: slog.LevelWarn,
                        ServerErrorLevel: slog.LevelError,

                        WithUserAgent:      true,
                        WithRequestID:      false, // We handle it ourselves (tracing middleware)
                        WithRequestHeader:  true,
                        WithResponseHeader: true,
                        WithSpanID:         true,
                        WithTraceID:        true,
                }),
                middleware.NewRecovererMiddleware(deps.RootLogger),
        )
        return chain(deps.MuxRouterAdapter.mux)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package server

import (
        "net/http"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(
                container,
                di.ProvideValue(http.NewServeMux()),
                NewMuxRouterAdapter,
                NewRootHandler,
                NewHTTPServer,
        )
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package server

import (
        "net/http"

        "go.uber.org/dig"
)

type MuxRouterAdapter struct {
        mux *http.ServeMux
}

func (r *MuxRouterAdapter) PathValue(req *http.Request, paramName string) string <span class="cov1" title="1">{
        return req.PathValue(paramName)
}</span>

func (r *MuxRouterAdapter) HandleRoute(method, pathPattern string, h http.Handler) <span class="cov10" title="10">{
        r.mux.Handle(method+" "+pathPattern, h)
}</span>

func NewMuxRouterAdapter(mux *http.ServeMux) *MuxRouterAdapter <span class="cov6" title="4">{
        return &amp;MuxRouterAdapter{
                mux: mux,
        }
}</span>

type Group struct {
        dig.Out

        RegisterHandlers RegisterHandlersFunc `group:"server"`
}

type RegisterHandlersFunc func()

func MakeHandlersGroupFactory[TController any, THttpApp any](
        registerFunc func(TController, THttpApp),
) func(ctrl TController, app THttpApp) Group <span class="cov1" title="1">{
        return func(ctrl TController, app THttpApp) Group </span><span class="cov1" title="1">{
                return Group{
                        RegisterHandlers: func() </span><span class="cov1" title="1">{ registerFunc(ctrl, app) }</span>,
                }
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package server

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "time"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/services"
        "go.uber.org/dig"
)

type HTTPServerDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        Port              int           `name:"config.httpServer.port"`
        IdleTimeout       time.Duration `name:"config.httpServer.idleTimeout"`
        ReadHeaderTimeout time.Duration `name:"config.httpServer.readHeaderTimeout"`
        ReadTimeout       time.Duration `name:"config.httpServer.readTimeout"`
        WriteTimeout      time.Duration `name:"config.httpServer.writeTimeout"`

        Handler http.Handler

        // services
        *services.ShutdownHooks
}

type HTTPServer struct {
        httpSrv *http.Server
        deps    HTTPServerDeps
        logger  *slog.Logger
}

func (srv *HTTPServer) Start(ctx context.Context) error <span class="cov1" title="1">{
        srv.logger.InfoContext(ctx, "Starting http listener",
                slog.String("addr", srv.httpSrv.Addr),
                slog.String("idleTimeout", srv.deps.IdleTimeout.String()),
                slog.String("readHeaderTimeout", srv.deps.ReadHeaderTimeout.String()),
                slog.String("readTimeout", srv.deps.ReadTimeout.String()),
                slog.String("writeTimeout", srv.deps.WriteTimeout.String()),
        )
        return srv.httpSrv.ListenAndServe()
}</span>

// NewHTTPServer constructor factory for general use *http.Server.
func NewHTTPServer(deps HTTPServerDeps) *HTTPServer <span class="cov10" title="2">{
        address := fmt.Sprintf("[::]:%d", deps.Port)
        srv := &amp;http.Server{
                Addr:              address,
                IdleTimeout:       deps.IdleTimeout,
                ReadHeaderTimeout: deps.ReadHeaderTimeout,
                ReadTimeout:       deps.ReadTimeout,
                WriteTimeout:      deps.WriteTimeout,
                Handler:           deps.Handler,
                ErrorLog:          slog.NewLogLogger(deps.RootLogger.Handler(), slog.LevelError),
        }

        deps.ShutdownHooks.Register("http-server", srv.Shutdown)

        return &amp;HTTPServer{
                deps:    deps,
                httpSrv: srv,
                logger:  deps.RootLogger.WithGroup("http-server"),
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package v1controllers

import (
        "context"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/handlers"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/models"
        "go.uber.org/dig"
)

func healthCheck(_ context.Context) error <span class="cov1" title="1">{
        // noop
        return nil
}</span>

type dummyMessagesCommands interface {
        PublishMessage(context.Context, *handlers.MessagesPublishDummyMessageRequest) error
        ProcessMessage(context.Context, *models.DummyMessage) error
}

type MessagesControllerDeps struct {
        dig.In

        Commands dummyMessagesCommands
}

func NewMessagesController(deps MessagesControllerDeps) *handlers.MessagesController <span class="cov10" title="4">{
        return handlers.BuildMessagesController().
                HandleHealthCheck.With(healthCheck).
                HandlePublishDummyMessage.With(deps.Commands.PublishMessage).
                HandleProcessDummyMessage.With(
                func(ctx context.Context, mpmr *handlers.MessagesProcessDummyMessageRequest) error </span><span class="cov1" title="1">{
                        return deps.Commands.ProcessMessage(ctx, mpmr.Payload)
                }</span>).
                Finalize()
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package v1controllers

import (
        context "context"

        handlers "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/handlers"
        mock "github.com/stretchr/testify/mock"

        models "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/models"
)

// mockDummyMessagesCommands is an autogenerated mock type for the dummyMessagesCommands type
type mockDummyMessagesCommands struct {
        mock.Mock
}

type mockDummyMessagesCommands_Expecter struct {
        mock *mock.Mock
}

func (_m *mockDummyMessagesCommands) EXPECT() *mockDummyMessagesCommands_Expecter <span class="cov1" title="1">{
        return &amp;mockDummyMessagesCommands_Expecter{mock: &amp;_m.Mock}
}</span>

// ProcessMessage provides a mock function with given fields: _a0, _a1
func (_m *mockDummyMessagesCommands) ProcessMessage(_a0 context.Context, _a1 *models.DummyMessage) error <span class="cov1" title="1">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ProcessMessage")</span>
        }

        <span class="cov1" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.DummyMessage) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov1" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov1" title="1">return r0</span>
}

// mockDummyMessagesCommands_ProcessMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProcessMessage'
type mockDummyMessagesCommands_ProcessMessage_Call struct {
        *mock.Call
}

// ProcessMessage is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *models.DummyMessage
func (_e *mockDummyMessagesCommands_Expecter) ProcessMessage(_a0 interface{}, _a1 interface{}) *mockDummyMessagesCommands_ProcessMessage_Call <span class="cov1" title="1">{
        return &amp;mockDummyMessagesCommands_ProcessMessage_Call{Call: _e.mock.On("ProcessMessage", _a0, _a1)}
}</span>

func (_c *mockDummyMessagesCommands_ProcessMessage_Call) Run(run func(_a0 context.Context, _a1 *models.DummyMessage)) *mockDummyMessagesCommands_ProcessMessage_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*models.DummyMessage))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *mockDummyMessagesCommands_ProcessMessage_Call) Return(_a0 error) *mockDummyMessagesCommands_ProcessMessage_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *mockDummyMessagesCommands_ProcessMessage_Call) RunAndReturn(run func(context.Context, *models.DummyMessage) error) *mockDummyMessagesCommands_ProcessMessage_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// PublishMessage provides a mock function with given fields: _a0, _a1
func (_m *mockDummyMessagesCommands) PublishMessage(_a0 context.Context, _a1 *handlers.MessagesPublishDummyMessageRequest) error <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for PublishMessage")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *handlers.MessagesPublishDummyMessageRequest) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// mockDummyMessagesCommands_PublishMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMessage'
type mockDummyMessagesCommands_PublishMessage_Call struct {
        *mock.Call
}

// PublishMessage is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *handlers.MessagesPublishDummyMessageRequest
func (_e *mockDummyMessagesCommands_Expecter) PublishMessage(_a0 interface{}, _a1 interface{}) *mockDummyMessagesCommands_PublishMessage_Call <span class="cov0" title="0">{
        return &amp;mockDummyMessagesCommands_PublishMessage_Call{Call: _e.mock.On("PublishMessage", _a0, _a1)}
}</span>

func (_c *mockDummyMessagesCommands_PublishMessage_Call) Run(run func(_a0 context.Context, _a1 *handlers.MessagesPublishDummyMessageRequest)) *mockDummyMessagesCommands_PublishMessage_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*handlers.MessagesPublishDummyMessageRequest))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *mockDummyMessagesCommands_PublishMessage_Call) Return(_a0 error) *mockDummyMessagesCommands_PublishMessage_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *mockDummyMessagesCommands_PublishMessage_Call) RunAndReturn(run func(context.Context, *handlers.MessagesPublishDummyMessageRequest) error) *mockDummyMessagesCommands_PublishMessage_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// newMockDummyMessagesCommands creates a new instance of mockDummyMessagesCommands. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockDummyMessagesCommands(t interface {
        mock.TestingT
        Cleanup(func())
}) *mockDummyMessagesCommands <span class="cov10" title="3">{
        mock := &amp;mockDummyMessagesCommands{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="3">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="3">return mock</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package v1controllers

import (
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/app"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                di.ProvideAs[*app.Commands, dummyMessagesCommands],

                NewMessagesController,
        )
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by apigen DO NOT EDIT.

package handlers

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/internal"
        "golang.org/x/exp/constraints"
)

type httpRouter interface {
        // PathValue returns a named path parameter of a given name
        PathValue(r *http.Request, paramName string) string

        // HandleRoute register a given handler function to handle given route
        HandleRoute(method, pathPattern string, h http.Handler)
}

// ParsingErrorHandler will process errors during parsing and validation stages
// The default implementation will respond with 400 status code and standard
// serialization of ParsingError type.
type ParsingErrorHandler func(r *http.Request, w http.ResponseWriter, err error)

// ActionErrorHandler will process errors produced by controller actions
// The default implementation will respond with 500 and no output.
type ActionErrorHandler func(r *http.Request, w http.ResponseWriter, err error)

// ResponseErrorHandler will process errors that may occur while writing response
// At this stage either logging or panic is possible.
type ResponseErrorHandler func(r *http.Request, err error)

// SlogLogger is a fully compatible with slog and used to allow injecting the instance.
type SlogLogger interface {
        Log(ctx context.Context, level slog.Level, msg string, args ...any)
        LogAttrs(ctx context.Context, level slog.Level, msg string, attrs ...slog.Attr)
}

type HTTPApp struct {
        router               httpRouter
        handleParsingErrors  ParsingErrorHandler
        handleActionErrors   ActionErrorHandler
        handleResponseErrors ResponseErrorHandler
        knownParsers         *knownParsersDef
        logger               SlogLogger
}

type HTTPAppOpt func(app *HTTPApp)

func WithParsingErrorHandler(handler ParsingErrorHandler) HTTPAppOpt <span class="cov0" title="0">{
        return func(app *HTTPApp) </span><span class="cov0" title="0">{
                app.handleParsingErrors = handler
        }</span>
}

func WithActionErrorHandler(handler ActionErrorHandler) HTTPAppOpt <span class="cov1" title="1">{
        return func(app *HTTPApp) </span><span class="cov1" title="1">{
                app.handleActionErrors = handler
        }</span>
}

func WithResponseErrorHandler(handler ResponseErrorHandler) HTTPAppOpt <span class="cov0" title="0">{
        return func(app *HTTPApp) </span><span class="cov0" title="0">{
                app.handleResponseErrors = handler
        }</span>
}

func WithLogger(logger SlogLogger) HTTPAppOpt <span class="cov1" title="1">{
        return func(app *HTTPApp) </span><span class="cov1" title="1">{
                app.logger = logger
        }</span>
}

func NewHTTPApp(router httpRouter, opts ...HTTPAppOpt) *HTTPApp <span class="cov4" title="3">{
        app := &amp;HTTPApp{
                router:       router,
                logger:       slog.Default(),
                knownParsers: newKnownParsers(),
        }
        app.handleResponseErrors = func(r *http.Request, err error) </span><span class="cov0" title="0">{
                app.logger.LogAttrs(r.Context(), slog.LevelError, "Failed to write response", slog.Any("err", err))
        }</span>
        <span class="cov4" title="3">app.handleParsingErrors = func(r *http.Request, w http.ResponseWriter, err error) </span><span class="cov0" title="0">{
                w.Header().Add("content-type", "application/json; charset=utf-8")
                w.WriteHeader(http.StatusBadRequest)
                app.logger.LogAttrs(r.Context(), slog.LevelWarn, "Failed to parse request", slog.Any("err", err))
                var aggregatedErr internal.AggregatedBindingError
                if ok := errors.As(err, &amp;aggregatedErr); ok </span><span class="cov0" title="0">{
                        if writeErr := json.NewEncoder(w).Encode(aggregatedErr); writeErr != nil </span><span class="cov0" title="0">{
                                app.handleResponseErrors(r, writeErr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }
        <span class="cov4" title="3">for _, opt := range opts </span><span class="cov3" title="2">{
                opt(app)
        }</span>
        <span class="cov4" title="3">return app</span>
}

type voidValue *int

type httpHandlerFactory func(app *HTTPApp) http.Handler
type paramsParser[TReqParams any] interface {
        parse(router httpRouter, req *http.Request) (TReqParams, error)
}
type paramsParserFactory[TReqParams any] func(app *HTTPApp) paramsParser[TReqParams]

type voidParamsParser struct{}

func (p voidParamsParser) parse(_ httpRouter, _ *http.Request) (voidValue, error) <span class="cov1" title="1">{
        return voidValue(nil), nil
}</span>

func makeVoidParamsParser(_ *HTTPApp) paramsParser[voidValue] <span class="cov4" title="3">{
        return voidParamsParser{}
}</span>

type handlerFactoryParams[TReqParams any, TResData any] struct {
        defaultStatus       int
        voidResult          bool
        paramsParserFactory func(app *HTTPApp) paramsParser[TReqParams]
        handler             func(context.Context, TReqParams) (TResData, error)
}

func mustInitializeAction(actionName string, handlerFactory httpHandlerFactory) httpHandlerFactory <span class="cov10" title="12">{
        if handlerFactory == nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("%s action has not been initialized", actionName))</span>
        }
        <span class="cov10" title="12">return handlerFactory</span>
}

func createHandlerFactory[TReqParams any, TResData any](
        factoryParams handlerFactoryParams[TReqParams, TResData],
) httpHandlerFactory <span class="cov10" title="12">{
        return func(app *HTTPApp) http.Handler </span><span class="cov8" title="9">{
                paramsParser := factoryParams.paramsParserFactory(app)
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov3" title="2">{
                        params, err := paramsParser.parse(app.router, r)
                        if err != nil </span><span class="cov0" title="0">{
                                app.handleParsingErrors(r, w, err)
                                return
                        }</span>

                        <span class="cov3" title="2">resData, err := factoryParams.handler(r.Context(), params)
                        if err != nil </span><span class="cov0" title="0">{
                                app.handleActionErrors(r, w, err)
                                return
                        }</span>
                        <span class="cov3" title="2">if factoryParams.voidResult </span><span class="cov3" title="2">{
                                w.WriteHeader(factoryParams.defaultStatus)
                                return
                        }</span>

                        <span class="cov0" title="0">w.Header().Add("Content-Type", "application/json; charset=utf-8")
                        w.WriteHeader(factoryParams.defaultStatus)
                        if encodingErr := json.NewEncoder(w).Encode(resData); encodingErr != nil </span><span class="cov0" title="0">{
                                app.handleResponseErrors(r, encodingErr)
                        }</span>
                })
        }
}

type actionBuilder[TControllerBuilder any, TReqParams any, TResData any] struct {
        defaultStatusCode   int
        voidResult          bool
        httpHandlerFactory  func(app *HTTPApp) http.Handler
        paramsParserFactory paramsParserFactory[TReqParams]
        controllerBuilder   TControllerBuilder
}

func (ab *actionBuilder[TControllerBuilder, TReqParams, TResData]) With(
        handler func(context.Context, TReqParams) (TResData, error),
) TControllerBuilder <span class="cov10" title="12">{
        ab.httpHandlerFactory = createHandlerFactory(handlerFactoryParams[TReqParams, TResData]{
                defaultStatus:       ab.defaultStatusCode,
                voidResult:          ab.voidResult,
                paramsParserFactory: ab.paramsParserFactory,
                handler:             handler,
        })
        return ab.controllerBuilder
}</span>

type actionBuilderVoidResult[TControllerBuilder any, TReqParams any] struct {
        actionBuilder[TControllerBuilder, TReqParams, voidValue]
}

func (ab *actionBuilderVoidResult[TControllerBuilder, TReqParams]) With(
        handler func(context.Context, TReqParams) error,
) TControllerBuilder <span class="cov8" title="8">{
        return ab.actionBuilder.With(func(ctx context.Context, tp TReqParams) (voidValue, error) </span><span class="cov1" title="1">{
                return nil, handler(ctx, tp)
        }</span>)
}

type actionBuilderNoParams[TControllerBuilder any, TResData any] struct {
        actionBuilder[TControllerBuilder, voidValue, TResData]
}

func (ab *actionBuilderNoParams[TControllerBuilder, TResData]) With(
        handler func(context.Context) (TResData, error),
) TControllerBuilder <span class="cov0" title="0">{
        return ab.actionBuilder.With(func(ctx context.Context, _ voidValue) (TResData, error) </span><span class="cov0" title="0">{
                return handler(ctx)
        }</span>)
}

type actionBuilderNoParamsVoidResult[TControllerBuilder any] struct {
        actionBuilder[TControllerBuilder, voidValue, voidValue]
}

func (ab *actionBuilderNoParamsVoidResult[TControllerBuilder]) With(
        handler func(context.Context) error,
) TControllerBuilder <span class="cov6" title="4">{
        return ab.actionBuilder.With(func(ctx context.Context, _ voidValue) (voidValue, error) </span><span class="cov1" title="1">{
                return nil, handler(ctx)
        }</span>)
}

func readPathValue(key string, router httpRouter, req *http.Request) internal.OptionalVal[string] <span class="cov0" title="0">{
        return internal.OptionalVal[string]{Value: router.PathValue(req, key), Assigned: true}
}</span>

func readQueryValue(key string, values url.Values) internal.OptionalVal[[]string] <span class="cov0" title="0">{
        if values.Has(key) </span><span class="cov0" title="0">{
                return internal.OptionalVal[[]string]{Value: values[key], Assigned: true}
        }</span>
        <span class="cov0" title="0">return internal.OptionalVal[[]string]{}</span>
}

func readRequestBodyValue(req *http.Request) internal.OptionalVal[*http.Request] <span class="cov1" title="1">{
        // We may need a different method to check if the body is empty
        // if content length approach will be causing issues. For this case
        // best would be to read the body to buffer and check its length. It will be fully consumed anyway.
        if req.ContentLength &gt; 0 </span><span class="cov1" title="1">{
                return internal.OptionalVal[*http.Request]{Value: req, Assigned: true}
        }</span>
        <span class="cov0" title="0">return internal.OptionalVal[*http.Request]{}</span>
}

type rawValueParser[TRawVal any, TTargetVal any] func(TRawVal, *TTargetVal) error

func parseJSONPayload[TTargetVal any](req *http.Request, target *TTargetVal) error <span class="cov1" title="1">{
        return json.NewDecoder(req.Body).Decode(target)
}</span>

var _ rawValueParser[*http.Request, string] = parseJSONPayload

func newStringToNumberParser[TTargetVal constraints.Integer | constraints.Float](
        bitSize int, parseFn func(string, int) (TTargetVal, error),
) rawValueParser[string, TTargetVal] <span class="cov10" title="12">{
        return func(ov string, target *TTargetVal) error </span><span class="cov0" title="0">{
                val, err := parseFn(ov, bitSize)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*target = val
                return nil</span>
        }
}

func newStringToDateTimeParser(isDateOnly bool) rawValueParser[string, time.Time] <span class="cov7" title="6">{
        return func(ov string, t *time.Time) error </span><span class="cov0" title="0">{
                format := time.RFC3339Nano
                if isDateOnly </span><span class="cov0" title="0">{
                        format = time.DateOnly
                }</span>
                <span class="cov0" title="0">val, err := time.Parse(format, ov)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*t = val
                return nil</span>
        }
}

func parseDecInt[TInt constraints.Integer](str string, bitSize int) (TInt, error) <span class="cov0" title="0">{
        res, err := strconv.ParseInt(str, 10, bitSize)
        return (TInt)(res), err
}</span>

func parseFloat[TFloat constraints.Float](str string, bitSize int) (TFloat, error) <span class="cov0" title="0">{
        res, err := strconv.ParseFloat(str, bitSize)
        return (TFloat)(res), err
}</span>

func parseMultiValueParamAsSoloValue[TTargetVal any](
        targetParser rawValueParser[string, TTargetVal],
) rawValueParser[[]string, TTargetVal] <span class="cov4" title="3">{
        return func(s []string, tv *TTargetVal) error </span><span class="cov0" title="0">{
                return targetParser(s[0], tv)
        }</span>
}

// parseSoloValueParamAsSoloValue is noop and used just to simplify templates.
func parseSoloValueParamAsSoloValue[TRawVal any, TTargetVal any](
        targetParser rawValueParser[TRawVal, TTargetVal],
) rawValueParser[TRawVal, TTargetVal] <span class="cov7" title="6">{
        return targetParser
}</span>

// parseSoloValueParamAsSlice will always parse the input as csv string.
func parseSoloValueParamAsSlice[TTargetVal any](
        targetParser rawValueParser[string, TTargetVal],
) rawValueParser[string, []TTargetVal] <span class="cov0" title="0">{
        return func(s string, tv *[]TTargetVal) error </span><span class="cov0" title="0">{
                items := strings.Split(s, ",")
                resultingSlice := make([]TTargetVal, 0, len(items))
                for i, item := range items </span><span class="cov0" title="0">{
                        var val TTargetVal
                        if err := targetParser(item, &amp;val); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to parse value at index %d: %w", i, err)
                        }</span>
                        <span class="cov0" title="0">resultingSlice = append(resultingSlice, val)</span>
                }
                <span class="cov0" title="0">*tv = resultingSlice
                return nil</span>
        }
}

// parseMultiValueParamAsSlice will parse each value in the input slice separately.
func parseMultiValueParamAsSlice[TTargetVal any](
        targetParser rawValueParser[string, TTargetVal],
) rawValueParser[[]string, []TTargetVal] <span class="cov0" title="0">{
        return func(s []string, tv *[]TTargetVal) error </span><span class="cov0" title="0">{
                resultingSlice := make([]TTargetVal, 0, len(s))
                for i, item := range s </span><span class="cov0" title="0">{
                        var val TTargetVal
                        if err := targetParser(item, &amp;val); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to parse value at index %d: %w", i, err)
                        }</span>
                        <span class="cov0" title="0">resultingSlice = append(resultingSlice, val)</span>
                }
                <span class="cov0" title="0">*tv = resultingSlice
                return nil</span>
        }
}

func parseNullableParam[TTargetVal any](
        targetParser rawValueParser[string, TTargetVal],
) rawValueParser[string, *TTargetVal] <span class="cov0" title="0">{
        return func(s string, tv **TTargetVal) error </span><span class="cov0" title="0">{
                if s == "" || s == "null" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">*tv = new(TTargetVal)
                return targetParser(s, *tv)</span>
        }
}

type knownParsersDef struct {
        stringParser  rawValueParser[string, string]
        dateParser    rawValueParser[string, time.Time]
        timeParser    rawValueParser[string, time.Time]
        int32Parser   rawValueParser[string, int32]
        int64Parser   rawValueParser[string, int64]
        float32Parser rawValueParser[string, float32]
        float64Parser rawValueParser[string, float64]
        boolParser    rawValueParser[string, bool]
}

const bitSize32 = 32
const bitSize64 = 64

func newKnownParsers() *knownParsersDef <span class="cov4" title="3">{
        return &amp;knownParsersDef{
                stringParser: func(ov string, s *string) error </span><span class="cov0" title="0">{
                        *s = ov
                        return nil
                }</span>,
                dateParser:    newStringToDateTimeParser(true),
                timeParser:    newStringToDateTimeParser(false),
                int32Parser:   newStringToNumberParser[int32](bitSize32, parseDecInt),
                int64Parser:   newStringToNumberParser[int64](bitSize64, parseDecInt),
                float32Parser: newStringToNumberParser[float32](bitSize32, parseFloat),
                float64Parser: newStringToNumberParser(bitSize64, strconv.ParseFloat),
                boolParser: func(ov string, s *bool) error <span class="cov0" title="0">{
                        switch ov </span>{
                        case "true":<span class="cov0" title="0">
                                *s = true</span>
                        case "false":<span class="cov0" title="0">
                                *s = false</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("unexpected boolean format %v", ov)</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                },
        }
}

type requestParamBinder[TRawVal any, TTargetVal any] func(
        bindingCtx *internal.BindingContext,
        rawVal internal.OptionalVal[TRawVal],
        receiver *TTargetVal,
)

type binderParams[TRawVal any, TTargetVal any] struct {
        required      bool
        parseValue    rawValueParser[TRawVal, TTargetVal]
        validateValue internal.FieldValidator[TTargetVal]
}

func newRequestParamBinder[TRawVal any, TTargetVal any](
        params binderParams[TRawVal, TTargetVal],
) requestParamBinder[TRawVal, TTargetVal] <span class="cov8" title="9">{
        return func(
                bindingCtx *internal.BindingContext,
                rawVal internal.OptionalVal[TRawVal],
                receiver *TTargetVal,
        ) </span><span class="cov1" title="1">{
                if !rawVal.Assigned </span><span class="cov0" title="0">{
                        if params.required </span><span class="cov0" title="0">{
                                bindingCtx.AppendFieldError(internal.FieldBindingError{
                                        Location: bindingCtx.BuildPath(),
                                        Code:     internal.ErrValueRequired.Error(),
                                })
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov1" title="1">if err := params.parseValue(rawVal.Value, receiver); err != nil </span><span class="cov0" title="0">{
                        bindingCtx.AppendFieldError(internal.FieldBindingError{
                                Location: bindingCtx.BuildPath(),
                                Code:     internal.ErrBadValueFormat.Error(),
                                Err:      err,
                        })
                        return
                }</span>
                <span class="cov1" title="1">params.validateValue(bindingCtx, *receiver)</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by apigen DO NOT EDIT.

package handlers

import (
        "encoding/json"
        "fmt"
        "time"

        . "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/models"
)

// Below is to workaround unused imports.
var _ = time.Time{}
var _ = json.Unmarshal
var _ = fmt.Sprint

type MessagesPublishDummyMessageTarget string

// List of MessagesPublishDummyMessageTarget values.
const (
        MessagesPublishDummyMessageTargetSNS MessagesPublishDummyMessageTarget = "SNS"
        MessagesPublishDummyMessageTargetEVENTBRIDGE MessagesPublishDummyMessageTarget = "EVENT_BRIDGE"
)

func(v MessagesPublishDummyMessageTarget) IsSNS() bool <span class="cov0" title="0">{
  return v == MessagesPublishDummyMessageTargetSNS
}</span>

func(v MessagesPublishDummyMessageTarget) IsEVENTBRIDGE() bool <span class="cov0" title="0">{
  return v == MessagesPublishDummyMessageTargetEVENTBRIDGE
}</span>

func(v MessagesPublishDummyMessageTarget) String() string <span class="cov0" title="0">{
        return string(v)
}</span>

type assignableMessagesPublishDummyMessageTarget interface {
        IsSNS() bool
        IsEVENTBRIDGE() bool
        String() string
}

func AsMessagesPublishDummyMessageTarget(v assignableMessagesPublishDummyMessageTarget) (MessagesPublishDummyMessageTarget) <span class="cov0" title="0">{
        return MessagesPublishDummyMessageTarget(v.String())
}</span>

func ParseMessagesPublishDummyMessageTarget(str string, target *MessagesPublishDummyMessageTarget) error <span class="cov0" title="0">{
        switch str </span>{
        case "SNS":<span class="cov0" title="0">
                *target = MessagesPublishDummyMessageTargetSNS</span>
        case "EVENT_BRIDGE":<span class="cov0" title="0">
                *target = MessagesPublishDummyMessageTargetEVENTBRIDGE</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unexpected MessagesPublishDummyMessageTarget value: %s", str)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (v *MessagesPublishDummyMessageTarget) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var str string
        if err := json.Unmarshal(data, &amp;str); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return ParseMessagesPublishDummyMessageTarget(str, v)</span>
}

// All allowed values of MessagesPublishDummyMessageTarget enum.
var AllowableMessagesPublishDummyMessageTargetValues = []MessagesPublishDummyMessageTarget{
        MessagesPublishDummyMessageTargetSNS,
        MessagesPublishDummyMessageTargetEVENTBRIDGE,
}



// MessagesProcessDummyMessageRequest represents params for processDummyMessage operation
//
// Request: POST /dummy-messages/process.
type MessagesProcessDummyMessageRequest struct {
        // Payload is parsed from request body and declared as payload.
        Payload *DummyMessage
}

// MessagesPublishDummyMessageRequest represents params for publishDummyMessage operation
//
// Request: POST /dummy-messages/publish.
type MessagesPublishDummyMessageRequest struct {
        // Target is parsed from request query and declared as target.
        Target MessagesPublishDummyMessageTarget
        // Payload is parsed from request body and declared as payload.
        Payload *DummyMessage
}

type MessagesController struct {
        // GET /health
        //
        // Request type: none
        //
        // Response type: none
        HealthCheck httpHandlerFactory

        // POST /dummy-messages/process
        //
        // Request type: MessagesProcessDummyMessageRequest,
        //
        // Response type: none
        ProcessDummyMessage httpHandlerFactory

        // POST /dummy-messages/publish
        //
        // Request type: MessagesPublishDummyMessageRequest,
        //
        // Response type: none
        PublishDummyMessage httpHandlerFactory
}

type MessagesControllerBuilder struct {
        // GET /health
        //
        // Request type: none
        //
        // Response type: none
        HandleHealthCheck actionBuilderNoParamsVoidResult[*MessagesControllerBuilder]

        // POST /dummy-messages/process
        //
        // Request type: MessagesProcessDummyMessageRequest,
        //
        // Response type: none
        HandleProcessDummyMessage actionBuilderVoidResult[*MessagesControllerBuilder, *MessagesProcessDummyMessageRequest]

        // POST /dummy-messages/publish
        //
        // Request type: MessagesPublishDummyMessageRequest,
        //
        // Response type: none
        HandlePublishDummyMessage actionBuilderVoidResult[*MessagesControllerBuilder, *MessagesPublishDummyMessageRequest]
}

func (c *MessagesControllerBuilder) Finalize() *MessagesController <span class="cov10" title="4">{
        return &amp;MessagesController{
                HealthCheck: mustInitializeAction("healthCheck", c.HandleHealthCheck.httpHandlerFactory),
                ProcessDummyMessage: mustInitializeAction("processDummyMessage", c.HandleProcessDummyMessage.httpHandlerFactory),
                PublishDummyMessage: mustInitializeAction("publishDummyMessage", c.HandlePublishDummyMessage.httpHandlerFactory),
        }
}</span>

func BuildMessagesController() *MessagesControllerBuilder <span class="cov10" title="4">{
        controllerBuilder := &amp;MessagesControllerBuilder{}

        // GET /health
        controllerBuilder.HandleHealthCheck.controllerBuilder = controllerBuilder
        controllerBuilder.HandleHealthCheck.defaultStatusCode = 204
        controllerBuilder.HandleHealthCheck.voidResult = true
        controllerBuilder.HandleHealthCheck.paramsParserFactory = makeVoidParamsParser

        // POST /dummy-messages/process
        controllerBuilder.HandleProcessDummyMessage.controllerBuilder = controllerBuilder
        controllerBuilder.HandleProcessDummyMessage.defaultStatusCode = 204
        controllerBuilder.HandleProcessDummyMessage.voidResult = true
        controllerBuilder.HandleProcessDummyMessage.paramsParserFactory = newParamsParserMessagesProcessDummyMessage

        // POST /dummy-messages/publish
        controllerBuilder.HandlePublishDummyMessage.controllerBuilder = controllerBuilder
        controllerBuilder.HandlePublishDummyMessage.defaultStatusCode = 202
        controllerBuilder.HandlePublishDummyMessage.voidResult = true
        controllerBuilder.HandlePublishDummyMessage.paramsParserFactory = newParamsParserMessagesPublishDummyMessage

        return controllerBuilder
}</span>

func RegisterMessagesRoutes(controller *MessagesController, app *HTTPApp) <span class="cov8" title="3">{
        app.router.HandleRoute("GET", "/health", controller.HealthCheck(app))
        app.router.HandleRoute("POST", "/dummy-messages/process", controller.ProcessDummyMessage(app))
        app.router.HandleRoute("POST", "/dummy-messages/publish", controller.PublishDummyMessage(app))
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by apigen DO NOT EDIT.

package handlers

import (
        "net/http"
        "time"

        . "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/models"
        . "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/internal"
)

// Below is to workaround unused imports.
var _ = time.Time{}
type _ func() DummyMessage

type paramsParserMessagesProcessDummyMessage struct {
        bindPayload requestParamBinder[*http.Request, *DummyMessage]
}

func (p *paramsParserMessagesProcessDummyMessage) parse(router httpRouter, req *http.Request) (*MessagesProcessDummyMessageRequest, error) <span class="cov1" title="1">{
        bindingCtx := BindingContext{}
        reqParams := &amp;MessagesProcessDummyMessageRequest{}
        // body params
        p.bindPayload(bindingCtx.Fork("body"), readRequestBodyValue(req), &amp;reqParams.Payload)
        return reqParams, bindingCtx.AggregatedError()
}</span>

func newParamsParserMessagesProcessDummyMessage(app *HTTPApp) paramsParser[*MessagesProcessDummyMessageRequest] <span class="cov10" title="3">{
        return &amp;paramsParserMessagesProcessDummyMessage{
                bindPayload: newRequestParamBinder(binderParams[*http.Request, *DummyMessage]{
                        required: true,
                        parseValue: parseSoloValueParamAsSoloValue(
                                parseJSONPayload[*DummyMessage],
                        ),
                        validateValue: NewDummyMessageValidator(),
                }),
        }
}</span>

type paramsParserMessagesPublishDummyMessage struct {
        bindTarget requestParamBinder[[]string, MessagesPublishDummyMessageTarget]
        bindPayload requestParamBinder[*http.Request, *DummyMessage]
}

func (p *paramsParserMessagesPublishDummyMessage) parse(router httpRouter, req *http.Request) (*MessagesPublishDummyMessageRequest, error) <span class="cov0" title="0">{
        bindingCtx := BindingContext{}
        reqParams := &amp;MessagesPublishDummyMessageRequest{}
        // query params
        query := req.URL.Query()
        queryParamsCtx := bindingCtx.Fork("query")
        p.bindTarget(queryParamsCtx.Fork("target"), readQueryValue("target", query), &amp;reqParams.Target)
        // body params
        p.bindPayload(bindingCtx.Fork("body"), readRequestBodyValue(req), &amp;reqParams.Payload)
        return reqParams, bindingCtx.AggregatedError()
}</span>

func newParamsParserMessagesPublishDummyMessage(app *HTTPApp) paramsParser[*MessagesPublishDummyMessageRequest] <span class="cov10" title="3">{
        return &amp;paramsParserMessagesPublishDummyMessage{
                bindTarget: newRequestParamBinder(binderParams[[]string, MessagesPublishDummyMessageTarget]{
                        required: true,
                        parseValue: parseMultiValueParamAsSoloValue(
                                ParseMessagesPublishDummyMessageTarget,
                        ),
                        validateValue: NewSimpleFieldValidator[MessagesPublishDummyMessageTarget](
                        ),
                }),
                bindPayload: newRequestParamBinder(binderParams[*http.Request, *DummyMessage]{
                        required: true,
                        parseValue: parseSoloValueParamAsSoloValue(
                                parseJSONPayload[*DummyMessage],
                        ),
                        validateValue: NewDummyMessageValidator(),
                }),
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by apigen DO NOT EDIT.

package internal

import (
        "time"
        . "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/models"
)

// Below is to workaround unused imports.
var _ = time.Time{}

func NewDummyMessageValidator() FieldValidator[*DummyMessage] <span class="cov10" title="6">{
        validateMessage := NewSimpleFieldValidator[string](
                EnsureNonDefault[string],
        )
        validateFailProcessing := NewSimpleFieldValidator[bool](
        )
        
        return func(bindingCtx *BindingContext, value *DummyMessage) </span><span class="cov1" title="1">{
                validateMessage(bindingCtx.Fork("message"), value.Message)
                validateFailProcessing(bindingCtx.Fork("failProcessing"), value.FailProcessing)
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by apigen DO NOT EDIT.

package internal

import (
        "time"
        . "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/models"
)

// Below is to workaround unused imports.
var _ = time.Time{}

func NewErrorValidator() FieldValidator[*Error] <span class="cov0" title="0">{
        validateCode := NewSimpleFieldValidator[*interface{}](
                SkipNullValidator(EnsureNonDefault[interface{}]),
        )
        validateMessage := NewSimpleFieldValidator[string](
        )
        
        return func(bindingCtx *BindingContext, value *Error) </span><span class="cov0" title="0">{
                validateCode(bindingCtx.Fork("code"), value.Code)
                validateMessage(bindingCtx.Fork("message"), value.Message)
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by apigen DO NOT EDIT.

package internal

import (
        "errors"
        "fmt"
        "regexp"
        "strconv"

        "golang.org/x/exp/constraints"
)

type BindingError string

const (
        // ErrBadValueFormat error means data provided can not be parsed to a target type.
        ErrBadValueFormat BindingError = "BAD_FORMAT"

        // ErrValueRequired error code indicates that the required value has not been provided.
        ErrValueRequired BindingError = "INVALID_REQUIRED"

        // ErrInvalidValueOutOfRange error code indicates that the value is out of range of allowable values
        // this is usually when number is out of min/max range, or string is outside of limits.
        ErrInvalidValueOutOfRange BindingError = "INVALID_OUT_OF_RANGE"

        // ErrInvalidValue error code a generic validation error.
        ErrInvalidValue BindingError = "INVALID"
)

func (c BindingError) Error() string <span class="cov0" title="0">{
        return string(c)
}</span>

// FieldBindingError occurs at parsing/validation stage and holds
// context on field that the error is related to.
type FieldBindingError struct {
        Location string `json:"location"`
        Err      error  `json:"-"`
        Code     string `json:"code"`
}

func (be FieldBindingError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("field %s code=%s, error: %v", be.Location, be.Code, be.Err)
}</span>

type AggregatedBindingError struct {
        Errors []FieldBindingError `json:"errors"`
}

func (c AggregatedBindingError) Error() string <span class="cov0" title="0">{
        errs := make([]error, len(c.Errors))
        for i, err := range c.Errors </span><span class="cov0" title="0">{
                errs[i] = err
        }</span>
        <span class="cov0" title="0">return errors.Join(errs...).Error()</span>
}

type BindingContext struct {
        parent       *BindingContext
        field        string
        memoizedPath string
        errors       []FieldBindingError
}

func (c *BindingContext) Fork(field string) *BindingContext <span class="cov4" title="3">{
        return &amp;BindingContext{
                parent: c,
                field:  field,
        }
}</span>

func (c *BindingContext) BuildPath() string <span class="cov0" title="0">{
        if c.memoizedPath != "" </span><span class="cov0" title="0">{
                return c.memoizedPath
        }</span>
        <span class="cov0" title="0">if c.parent == nil </span><span class="cov0" title="0">{
                return c.field
        }</span>
        <span class="cov0" title="0">parentPath := c.parent.BuildPath()
        if parentPath == "" </span><span class="cov0" title="0">{
                c.memoizedPath = c.field
        }</span> else<span class="cov0" title="0"> {
                c.memoizedPath = parentPath + "." + c.field
        }</span>
        <span class="cov0" title="0">return c.memoizedPath</span>
}

func (c *BindingContext) AppendFieldError(err FieldBindingError) <span class="cov0" title="0">{
        if c.parent != nil </span><span class="cov0" title="0">{
                c.parent.AppendFieldError(err)
                return
        }</span>
        <span class="cov0" title="0">c.errors = append(c.errors, err)</span>
}

func (c BindingContext) AggregatedError() error <span class="cov1" title="1">{
        if c.parent != nil </span><span class="cov0" title="0">{
                return c.parent.AggregatedError()
        }</span>
        <span class="cov1" title="1">if len(c.errors) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return AggregatedBindingError{Errors: c.errors}</span>
}

type OptionalVal[TVal any] struct {
        Value    TVal
        Assigned bool
}

type ValueValidator[TTargetVal any] func(TTargetVal) error

// EnsureNonDefault will validate if given value is non default for given type.
//
// There is no easy way to make a truly required validation (e.g if field is present)
// without a custom marshaler and shadow models, which will impact performance.
// So keeping a non default validation as a reasonable tradeoff.
func EnsureNonDefault[TTargetVal comparable](val TTargetVal) error <span class="cov1" title="1">{
        var empty TTargetVal
        if val == empty </span><span class="cov0" title="0">{
                return fmt.Errorf("provided value %v is default for given type and considered empty: %w", val, ErrValueRequired)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

var _ = EnsureNonDefault[int]

// EnsureArrayFieldRequired will validate if given array is not empty.
func EnsureArrayFieldRequired[TTargetVal any](val []TTargetVal) error <span class="cov0" title="0">{
        if len(val) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("provided array is empty: %w", ErrValueRequired)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var _ = EnsureArrayFieldRequired[int]

func SkipNullValidator[TTargetVal any](target ValueValidator[TTargetVal]) ValueValidator[*TTargetVal] <span class="cov0" title="0">{
        return func(tv *TTargetVal) error </span><span class="cov0" title="0">{
                if tv == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return target(*tv)</span>
        }
}

func SkipNullFieldValidator[TTargetVal any](target FieldValidator[*TTargetVal]) FieldValidator[*TTargetVal] <span class="cov0" title="0">{
        return func(bindingCtx *BindingContext, value *TTargetVal) </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">target(bindingCtx, value)</span>
        }
}

func NewMinMaxValueValidator[TTargetVal constraints.Ordered](
        threshold TTargetVal,
        exclusive bool,
        isMin bool,
) ValueValidator[TTargetVal] <span class="cov0" title="0">{
        return func(tv TTargetVal) error </span><span class="cov0" title="0">{
                // From OpenAPI spec:
                // exclusiveMinimum: false or not included        value ≥ minimum
                // exclusiveMinimum: true        value &gt; minimum
                // exclusiveMaximum: false or not included        value ≤ maximum
                // exclusiveMaximum: true        value &lt; maximum

                if isMin &amp;&amp; ((exclusive &amp;&amp; tv &lt;= threshold) || (!exclusive &amp;&amp; tv &lt; threshold)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("value %v is less than minimum %v: %w", tv, threshold, ErrInvalidValueOutOfRange)
                }</span>
                <span class="cov0" title="0">if !isMin &amp;&amp; ((exclusive &amp;&amp; tv &gt;= threshold) || (!exclusive &amp;&amp; tv &gt; threshold)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("value %v is greater than maximum %v: %w", tv, threshold, ErrInvalidValueOutOfRange)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

type Measurable[T any] interface {
        ~string | ~[]T
}

func NewMinMaxLengthValidator[TTargetVal any, TValidatorVal Measurable[TTargetVal]](
        threshold int,
        isMin bool,
) ValueValidator[TValidatorVal] <span class="cov0" title="0">{
        return func(tv TValidatorVal) error </span><span class="cov0" title="0">{
                targetLen := len(tv)
                if isMin &amp;&amp; targetLen &lt; threshold </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "value %v has length (%d) less than minimum %v: %w",
                                tv, targetLen, threshold, ErrInvalidValueOutOfRange,
                        )
                }</span>
                <span class="cov0" title="0">if !isMin &amp;&amp; targetLen &gt; threshold </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "value %v has length (%d) more than maximum %v: %w", tv,
                                targetLen, threshold, ErrInvalidValueOutOfRange,
                        )
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

func NewPatternValidator[TTargetValue string](patternStr string) ValueValidator[string] <span class="cov0" title="0">{
        pattern := regexp.MustCompile(patternStr)
        return func(v string) error </span><span class="cov0" title="0">{
                if !pattern.MatchString(v) </span><span class="cov0" title="0">{
                        return fmt.Errorf("value %v does not match pattern %v: %w", v, patternStr, ErrInvalidValue)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

type FieldValidator[TValue any] func(
        bindingCtx *BindingContext,
        value TValue,
)

func NewSimpleFieldValidator[
        TValue any,
](validators ...ValueValidator[TValue]) FieldValidator[TValue] <span class="cov10" title="15">{
        return func(
                bindingCtx *BindingContext,
                value TValue,
        ) </span><span class="cov3" title="2">{
                for _, v := range validators </span><span class="cov1" title="1">{
                        if err := v(value); err != nil </span><span class="cov0" title="0">{
                                errCode := ErrInvalidValue
                                errors.As(err, &amp;errCode)
                                bindingCtx.AppendFieldError(FieldBindingError{
                                        Location: bindingCtx.BuildPath(),
                                        Code:     errCode.Error(),
                                        Err:      err,
                                })
                                return
                        }</span>
                }
        }
}

type ObjectFieldValidatorParams struct {
        Nullable bool
        Required bool
}

func NewObjectFieldValidator[TTargetVal any](
        params ObjectFieldValidatorParams,
        modelValidator FieldValidator[*TTargetVal],
) FieldValidator[*TTargetVal] <span class="cov0" title="0">{
        return func(bindingCtx *BindingContext, value *TTargetVal) </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        if params.Required &amp;&amp; !params.Nullable </span><span class="cov0" title="0">{
                                bindingCtx.AppendFieldError(FieldBindingError{
                                        Location: bindingCtx.BuildPath(),
                                        Code:     ErrValueRequired.Error(),
                                })
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">modelValidator(bindingCtx, value)</span>
        }
}

func NewArrayValidator[
        TValue any,
](
        validateField FieldValidator[[]TValue],
        validateItems FieldValidator[TValue],
) FieldValidator[[]TValue] <span class="cov0" title="0">{
        return func(
                bindingCtx *BindingContext,
                value []TValue,
        ) </span><span class="cov0" title="0">{
                validateField(bindingCtx, value)
                for i, v := range value </span><span class="cov0" title="0">{
                        // TODO: Consider fmt.Stringer approach, defer conversion and benchmark if makes noticeable difference.
                        validateItems(bindingCtx.Fork(strconv.Itoa(i)), v)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package app

import (
        "context"
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/handlers"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/models"
        "github.com/samber/lo"
        "go.uber.org/dig"
)

type messageSender[TMessage any] func(
        ctx context.Context,
        message *TMessage,
) error

type CommandsDeps struct {
        dig.In

        RootLogger *slog.Logger

        SendDummySNSMessage         messageSender[models.DummyMessage] `name:"dummy-sns-message-sender"`
        SendDummyEventBridgeMessage messageSender[models.DummyMessage] `name:"dummy-eventbridge-message-sender"`
}

type Commands struct {
        logger *slog.Logger
        deps   CommandsDeps
}

func (c *Commands) PublishMessage(ctx context.Context, req *handlers.MessagesPublishDummyMessageRequest) error <span class="cov6" title="3">{
        sendDummyMessage := lo.If(
                req.Target == handlers.MessagesPublishDummyMessageTargetSNS,
                c.deps.SendDummySNSMessage,
        ).Else(c.deps.SendDummyEventBridgeMessage)
        if err := sendDummyMessage(ctx, req.Payload); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to send message, %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>
}

func (c *Commands) ProcessMessage(ctx context.Context, msg *models.DummyMessage) error <span class="cov4" title="2">{
        c.logger.DebugContext(ctx, "Processing message", slog.Any("message", msg))

        if msg.FailProcessing </span><span class="cov1" title="1">{
                return errors.New("simulated processing error")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func NewCommands(deps CommandsDeps) *Commands <span class="cov10" title="6">{
        return &amp;Commands{
                logger: deps.RootLogger.WithGroup("app.commands"),
                deps:   deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package app

import (
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/api/http/v1routes/models"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/di"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi"
        "go.uber.org/dig"
)

type dummyMessagesSendersDeps struct {
        dig.In

        SnsDeps      awsapi.SNSMessageSenderDeps
        EventBusDeps awsapi.EventBusMessageSenderDeps

        DummyMessagesDetailType string `name:"config.aws.eventBus.dummyMessagesDetailType"`
        DummyMessagesTopicARN   string `name:"config.aws.sns.dummyMessagesTopicArn"`
}

type dummySendersOut struct {
        dig.Out

        SendDummySNSMessage         messageSender[models.DummyMessage] `name:"dummy-sns-message-sender"`
        SendDummyEventBridgeMessage messageSender[models.DummyMessage] `name:"dummy-eventbridge-message-sender"`
}

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(
                container,
                func(deps dummyMessagesSendersDeps) dummySendersOut </span><span class="cov8" title="1">{
                        return dummySendersOut{
                                SendDummySNSMessage: messageSender[models.DummyMessage](
                                        awsapi.NewSNSMessageSender[models.DummyMessage](deps.DummyMessagesTopicARN, deps.SnsDeps),
                                ),
                                SendDummyEventBridgeMessage: messageSender[models.DummyMessage](
                                        awsapi.NewEventBusMessageSender[models.DummyMessage](deps.DummyMessagesDetailType, deps.EventBusDeps),
                                ),
                        }
                }</span>,
                NewCommands,
        )
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package config

import (
        "embed"
        "fmt"
        "strings"

        "github.com/spf13/viper"
)

//go:embed *.json
var resources embed.FS

func mergeResourceCfg(cfg *viper.Viper, resourceName string) error <span class="cov10" title="21">{
        resourceStream, err := resources.Open(resourceName)
        if err != nil </span><span class="cov4" title="3">{
                return fmt.Errorf("failed to read config %v: %w", resourceName, err)
        }</span>
        <span class="cov9" title="18">defer resourceStream.Close()

        if err = cfg.MergeConfig(resourceStream); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config %v: %w", resourceName, err)
        }</span>
        <span class="cov9" title="18">return nil</span>
}

type LoadOpts struct {
        env                   string
        defaultConfigFileName string
}

func (opts *LoadOpts) WithEnv(val string) *LoadOpts <span class="cov7" title="9">{
        if val != "" </span><span class="cov6" title="7">{
                opts.env = val
        }</span>
        <span class="cov7" title="9">return opts</span>
}

func NewLoadOpts() *LoadOpts <span class="cov8" title="11">{
        return &amp;LoadOpts{
                env:                   "local",
                defaultConfigFileName: "default.json",
        }
}</span>

func New() *viper.Viper <span class="cov8" title="11">{
        v := viper.New()
        v.SetEnvPrefix("APP")
        v.SetConfigType("json")
        v.SetEnvKeyReplacer(
                strings.NewReplacer("-", "_", ".", "_"),
        )
        v.AutomaticEnv()
        return v
}</span>

func Load(cfg *viper.Viper, opts *LoadOpts) error <span class="cov8" title="11">{
        if err := mergeResourceCfg(cfg, opts.defaultConfigFileName); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="10">if err := mergeResourceCfg(cfg, opts.env+".json"); err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        // Some common aliases to have cli params with the same name as config keys
        <span class="cov7" title="8">cfg.RegisterAlias("defaultLogLevel", "log-level")
        cfg.RegisterAlias("jsonLogs", "json-logs")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package config

import (
        "fmt"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/di"
        "github.com/spf13/viper"
        "go.uber.org/dig"
)

type configValueProvider struct {
        cfg        *viper.Viper
        configPath string
        diPath     string
}

func provideConfigValue(cfg *viper.Viper, path string) configValueProvider <span class="cov10" title="21">{
        if !cfg.IsSet(path) </span><span class="cov1" title="1">{
                panic(fmt.Errorf("config key not found: %s", path))</span>
        }
        <span class="cov9" title="20">return configValueProvider{cfg, path, "config." + path}</span>
}

func (p configValueProvider) asInt() di.ConstructorWithOpts <span class="cov3" title="2">{
        return di.ProvideValue(p.cfg.GetInt(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asInt32() di.ConstructorWithOpts <span class="cov4" title="3">{
        return di.ProvideValue(p.cfg.GetInt32(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asString() di.ConstructorWithOpts <span class="cov7" title="8">{
        return di.ProvideValue(p.cfg.GetString(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asBool() di.ConstructorWithOpts <span class="cov1" title="1">{
        return di.ProvideValue(p.cfg.GetBool(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asDuration() di.ConstructorWithOpts <span class="cov6" title="6">{
        return di.ProvideValue(p.cfg.GetDuration(p.configPath), dig.Name(p.diPath))
}</span>

func Provide(container *dig.Container, cfg *viper.Viper) error <span class="cov1" title="1">{
        return di.ProvideAll(container,
                provideConfigValue(cfg, "gracefulShutdownTimeout").asDuration(),

                // http server config
                provideConfigValue(cfg, "httpServer.port").asInt(),
                provideConfigValue(cfg, "httpServer.idleTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.readHeaderTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.readTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.writeTimeout").asDuration(),

                // aws config
                provideConfigValue(cfg, "aws.region").asString(),
                provideConfigValue(cfg, "aws.baseEndpoint").asString(),
                provideConfigValue(cfg, "aws.eventBus.name").asString(),
                provideConfigValue(cfg, "aws.eventBus.source").asString(),
                provideConfigValue(cfg, "aws.eventBus.dummyMessagesDetailType").asString(),
                provideConfigValue(cfg, "aws.sns.dummyMessagesTopicArn").asString(),
                provideConfigValue(cfg, "aws.sqs.maxPollWaitTimeSec").asInt32(),
                provideConfigValue(cfg, "aws.sqs.dummyMessagesQueueUrl").asString(),
                provideConfigValue(cfg, "aws.sqs.dummyMessagesQueueVisibilityTimeoutSec").asInt32(),
        )
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package config

import (
        "github.com/samber/lo"
        "github.com/spf13/viper"
)

func LoadTestConfig() *viper.Viper <span class="cov10" title="4">{
        cfg := New()
        lo.Must0(Load(cfg, NewLoadOpts().WithEnv("test")))
        return cfg
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package di

import (
        "fmt"
        "reflect"

        "go.uber.org/dig"
)

// Dig is used as DI toolkit https://pkg.go.dev/go.uber.org/dig
// we are not creating any abstraction over it, but we do have a set of tools to make it easier to use

type ConstructorWithOpts struct {
        Constructor interface{}
        Options     []dig.ProvideOption
}

func ProvideAll(container *dig.Container, providers ...interface{}) error <span class="cov7" title="19">{
        for i, provider := range providers </span><span class="cov10" title="51">{
                switch p := provider.(type) </span>{
                case ConstructorWithOpts:<span class="cov8" title="28">
                        if err := container.Provide(p.Constructor, p.Options...); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                default:<span class="cov8" title="23">
                        if err := container.Provide(provider); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                }
        }
        <span class="cov7" title="17">return nil</span>
}

// ProvideValue will create a constructor (e.g func) from a given value.
func ProvideValue[T any](val T, opts ...dig.ProvideOption) ConstructorWithOpts <span class="cov8" title="29">{
        return ConstructorWithOpts{
                Constructor: func() T </span><span class="cov8" title="26">{ return val }</span>,
                Options:     opts,
        }
}

// ProvideWithArg will create a constructor with a first arg explicitly provided
// supposed return no error.
func ProvideWithArg[
        TArg any,
        TConstructorArg any,
        TRes any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) TRes,
) func(TConstructorArg) TRes <span class="cov1" title="1">{
        return func(cArg TConstructorArg) TRes </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideWithArgErr will create a constructor with a first arg explicitly provided
// supposed return an error.
func ProvideWithArgErr[
        TArg any,
        TConstructorArg any,
        TDep any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) (TDep, error),
) func(TConstructorArg) (TDep, error) <span class="cov1" title="1">{
        return func(cArg TConstructorArg) (TDep, error) </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideAs is used to provide one type as another, typically
// used to provide implementation struct as particular interface.
func ProvideAs[TSource any, TTarget any](source TSource) (TTarget, error) <span class="cov2" title="2">{
        target, ok := any(source).(TTarget)
        if !ok </span><span class="cov0" title="0">{
                return target, fmt.Errorf("failed to cast %s to %s",
                        reflect.TypeOf((*TSource)(nil)).Elem(), reflect.TypeOf((*TTarget)(nil)).Elem(),
                )
        }</span>
        <span class="cov2" title="2">return target, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package diag

import "log/slog"

func ErrAttr(err error) slog.Attr <span class="cov8" title="1">{
        return slog.Any("err", err)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package diag

import (
        context "context"
        slog "log/slog"

        mock "github.com/stretchr/testify/mock"
)

// MockSlogHandler is an autogenerated mock type for the Handler type
type MockSlogHandler struct {
        mock.Mock
}

type MockSlogHandler_Expecter struct {
        mock *mock.Mock
}

func (_m *MockSlogHandler) EXPECT() *MockSlogHandler_Expecter <span class="cov8" title="3">{
        return &amp;MockSlogHandler_Expecter{mock: &amp;_m.Mock}
}</span>

// Enabled provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Enabled(_a0 context.Context, _a1 slog.Level) bool <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Enabled")</span>
        }

        <span class="cov0" title="0">var r0 bool
        if rf, ok := ret.Get(0).(func(context.Context, slog.Level) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_Enabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enabled'
type MockSlogHandler_Enabled_Call struct {
        *mock.Call
}

// Enabled is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Level
func (_e *MockSlogHandler_Expecter) Enabled(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_Enabled_Call{Call: _e.mock.On("Enabled", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Enabled_Call) Run(run func(_a0 context.Context, _a1 slog.Level)) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Level))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Enabled_Call) Return(_a0 bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Enabled_Call) RunAndReturn(run func(context.Context, slog.Level) bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Handle provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Handle(_a0 context.Context, _a1 slog.Record) error <span class="cov5" title="2">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Handle")</span>
        }

        <span class="cov5" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, slog.Record) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov5" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov5" title="2">return r0</span>
}

// MockSlogHandler_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockSlogHandler_Handle_Call struct {
        *mock.Call
}

// Handle is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Record
func (_e *MockSlogHandler_Expecter) Handle(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        return &amp;MockSlogHandler_Handle_Call{Call: _e.mock.On("Handle", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Handle_Call) Run(run func(_a0 context.Context, _a1 slog.Record)) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Record))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Handle_Call) Return(_a0 error) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Handle_Call) RunAndReturn(run func(context.Context, slog.Record) error) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithAttrs provides a mock function with given fields: attrs
func (_m *MockSlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov1" title="1">{
        ret := _m.Called(attrs)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithAttrs")</span>
        }

        <span class="cov1" title="1">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func([]slog.Attr) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(attrs)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov1" title="1">return r0</span>
}

// MockSlogHandler_WithAttrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithAttrs'
type MockSlogHandler_WithAttrs_Call struct {
        *mock.Call
}

// WithAttrs is a helper method to define mock.On call
//   - attrs []slog.Attr
func (_e *MockSlogHandler_Expecter) WithAttrs(attrs interface{}) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        return &amp;MockSlogHandler_WithAttrs_Call{Call: _e.mock.On("WithAttrs", attrs)}
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) Run(run func(attrs []slog.Attr)) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]slog.Attr))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithAttrs_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) RunAndReturn(run func([]slog.Attr) slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithGroup provides a mock function with given fields: name
func (_m *MockSlogHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithGroup")</span>
        }

        <span class="cov0" title="0">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func(string) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_WithGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithGroup'
type MockSlogHandler_WithGroup_Call struct {
        *mock.Call
}

// WithGroup is a helper method to define mock.On call
//   - name string
func (_e *MockSlogHandler_Expecter) WithGroup(name interface{}) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_WithGroup_Call{Call: _e.mock.On("WithGroup", name)}
}</span>

func (_c *MockSlogHandler_WithGroup_Call) Run(run func(name string)) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithGroup_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithGroup_Call) RunAndReturn(run func(string) slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockSlogHandler creates a new instance of MockSlogHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSlogHandler(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSlogHandler <span class="cov10" title="4">{
        mock := &amp;MockSlogHandler{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package diag

import (
        "context"
        "io"
        "log/slog"
        "os"
)

type contextKey string

const (
        contextDiagAttrs = contextKey("diag.context-key.log-attribs")
)

type LogAttributes struct {
        CorrelationID slog.Value
}

func GetLogAttributesFromContext(ctx context.Context) LogAttributes <span class="cov5" title="7">{
        res, _ := ctx.Value(contextDiagAttrs).(LogAttributes)
        return res
}</span>

func SetLogAttributesToContext(ctx context.Context, attributes LogAttributes) context.Context <span class="cov4" title="5">{
        return context.WithValue(ctx, contextDiagAttrs, attributes)
}</span>

type diagLogHandler struct {
        target slog.Handler
}

func (h *diagLogHandler) Enabled(ctx context.Context, lvl slog.Level) bool <span class="cov9" title="42">{
        return h.target.Enabled(ctx, lvl)
}</span>

func (h *diagLogHandler) Handle(ctx context.Context, rec slog.Record) error <span class="cov10" title="44">{
        if diagAttributes, ok := ctx.Value(contextDiagAttrs).(LogAttributes); ok </span><span class="cov1" title="1">{
                rec.AddAttrs(
                        slog.Attr{Key: "correlationId", Value: diagAttributes.CorrelationID},
                )
        }</span>

        <span class="cov10" title="44">return h.target.Handle(ctx, rec)</span>
}

func (h *diagLogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov8" title="27">{
        return &amp;diagLogHandler{target: h.target.WithAttrs(attrs)}
}</span>

func (h *diagLogHandler) WithGroup(name string) slog.Handler <span class="cov8" title="26">{
        // Using WithAttrs here since group will nest all the attributes
        // inside of it (including correlationId), which makes it harder to
        // filter logs by the correlationId.
        // Consumers can use slog.Group if some attributes needs to be grouped
        return h.WithAttrs([]slog.Attr{slog.String("group", name)})
}</span>

var _ slog.Handler = &amp;diagLogHandler{}

type RootLoggerOpts struct {
        output io.Writer

        jsonLogs bool

        // Info is default (zero)
        logLevel slog.Level
}

func (opts *RootLoggerOpts) WithJSONLogs(value bool) *RootLoggerOpts <span class="cov2" title="2">{
        opts.jsonLogs = value
        return opts
}</span>

func (opts *RootLoggerOpts) WithLogLevel(logLevel slog.Level) *RootLoggerOpts <span class="cov8" title="22">{
        opts.logLevel = logLevel
        return opts
}</span>

func (opts *RootLoggerOpts) WithOutput(output io.Writer) *RootLoggerOpts <span class="cov8" title="20">{
        opts.output = output
        return opts
}</span>

func (opts *RootLoggerOpts) WithOptionalOutputFile(outputFile string) *RootLoggerOpts <span class="cov1" title="1">{
        if outputFile == "" </span><span class="cov0" title="0">{
                return opts
        }</span>
        <span class="cov1" title="1">f, err := os.OpenFile(outputFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov1" title="1">opts.output = f
        return opts</span>
}

func NewRootLoggerOpts() *RootLoggerOpts <span class="cov8" title="23">{
        return &amp;RootLoggerOpts{
                output: os.Stdout,
        }
}</span>

func SetupRootLogger(opts *RootLoggerOpts) *slog.Logger <span class="cov8" title="23">{
        logHandlerOpts := &amp;slog.HandlerOptions{Level: opts.logLevel}
        var logHandler slog.Handler
        if opts.jsonLogs </span><span class="cov1" title="1">{
                logHandler = slog.NewJSONHandler(opts.output, logHandlerOpts)
        }</span> else<span class="cov8" title="22"> {
                logHandler = slog.NewTextHandler(opts.output, logHandlerOpts)
        }</span>
        <span class="cov8" title="23">return slog.New(&amp;diagLogHandler{target: logHandler})</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">//go:build !release

// TODO: generated code should include "//go:build !release" tags
//go:generate mockgen -typed -package diag -destination mock_slog_handler_test.go log/slog Handler

package diag

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "runtime"
)

// openTestLogFile will open a log file in a project root directory.
func openTestLogFile() *os.File <span class="cov7" title="9">{
        _, filename, _, _ := runtime.Caller(0) // Will be current file
        testFilePath := filepath.Join(filename, "..", "..", "..", "test.log")
        f, err := os.OpenFile(testFilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("fail to open log file %q for test logging: %w", testFilePath, err)
                panic(err)</span>
        }
        <span class="cov7" title="9">return f</span>
}

var testOutput = openTestLogFile() //nolint:gochecknoglobals //it's ok for tests

func RootTestLogger() *slog.Logger <span class="cov10" title="20">{
        return SetupRootLogger(
                NewRootLoggerOpts().
                        WithLogLevel(slog.LevelDebug).
                        WithOutput(testOutput),
        )
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package queues

import (
        context "context"

        awsapi "github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi"

        mock "github.com/stretchr/testify/mock"
)

// mockMessagePoller is an autogenerated mock type for the messagePoller type
type mockMessagePoller struct {
        mock.Mock
}

type mockMessagePoller_Expecter struct {
        mock *mock.Mock
}

func (_m *mockMessagePoller) EXPECT() *mockMessagePoller_Expecter <span class="cov10" title="2">{
        return &amp;mockMessagePoller_Expecter{mock: &amp;_m.Mock}
}</span>

// RegisterQueue provides a mock function with given fields: queue
func (_m *mockMessagePoller) RegisterQueue(queue awsapi.MessagesPollerQueue) <span class="cov1" title="1">{
        _m.Called(queue)
}</span>

// mockMessagePoller_RegisterQueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterQueue'
type mockMessagePoller_RegisterQueue_Call struct {
        *mock.Call
}

// RegisterQueue is a helper method to define mock.On call
//   - queue awsapi.MessagesPollerQueue
func (_e *mockMessagePoller_Expecter) RegisterQueue(queue interface{}) *mockMessagePoller_RegisterQueue_Call <span class="cov1" title="1">{
        return &amp;mockMessagePoller_RegisterQueue_Call{Call: _e.mock.On("RegisterQueue", queue)}
}</span>

func (_c *mockMessagePoller_RegisterQueue_Call) Run(run func(queue awsapi.MessagesPollerQueue)) *mockMessagePoller_RegisterQueue_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(awsapi.MessagesPollerQueue))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *mockMessagePoller_RegisterQueue_Call) Return() *mockMessagePoller_RegisterQueue_Call <span class="cov0" title="0">{
        _c.Call.Return()
        return _c
}</span>

func (_c *mockMessagePoller_RegisterQueue_Call) RunAndReturn(run func(awsapi.MessagesPollerQueue)) *mockMessagePoller_RegisterQueue_Call <span class="cov0" title="0">{
        _c.Run(run)
        return _c
}</span>

// Start provides a mock function with given fields: ctx
func (_m *mockMessagePoller) Start(ctx context.Context) error <span class="cov1" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Start")</span>
        }

        <span class="cov1" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov1" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov1" title="1">return r0</span>
}

// mockMessagePoller_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type mockMessagePoller_Start_Call struct {
        *mock.Call
}

// Start is a helper method to define mock.On call
//   - ctx context.Context
func (_e *mockMessagePoller_Expecter) Start(ctx interface{}) *mockMessagePoller_Start_Call <span class="cov1" title="1">{
        return &amp;mockMessagePoller_Start_Call{Call: _e.mock.On("Start", ctx)}
}</span>

func (_c *mockMessagePoller_Start_Call) Run(run func(ctx context.Context)) *mockMessagePoller_Start_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *mockMessagePoller_Start_Call) Return(_a0 error) *mockMessagePoller_Start_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *mockMessagePoller_Start_Call) RunAndReturn(run func(context.Context) error) *mockMessagePoller_Start_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// newMockMessagePoller creates a new instance of mockMessagePoller. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockMessagePoller(t interface {
        mock.TestingT
        Cleanup(func())
}) *mockMessagePoller <span class="cov1" title="1">{
        mock := &amp;mockMessagePoller{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov1" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov1" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package queues

import (
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/di"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                di.ProvideAs[*awsapi.MessagesPoller, messagePoller],
        )
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package queues

import (
        "context"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/app"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/services"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi"
        "go.uber.org/dig"
)

type messagePoller interface {
        RegisterQueue(queue awsapi.MessagesPollerQueue)
        Start(ctx context.Context) error
}

type Deps struct {
        dig.In

        // config
        DummyMessagesQueueURL                  string `name:"config.aws.sqs.dummyMessagesQueueUrl"`
        DummyMessagesQueueVisibilityTimeoutSec int32  `name:"config.aws.sqs.dummyMessagesQueueVisibilityTimeoutSec"`

        // app layer
        Commands *app.Commands

        // services
        MessagesPoller messagePoller
        *services.ShutdownHooks
}

func StartPolling(ctx context.Context, deps Deps) error <span class="cov8" title="1">{
        queuesCtx, cancel := context.WithCancel(ctx)
        deps.ShutdownHooks.RegisterNoCtx("queues", func() error </span><span class="cov8" title="1">{
                cancel()
                return nil
        }</span>)

        <span class="cov8" title="1">poller := deps.MessagesPoller
        poller.RegisterQueue(awsapi.MessagesPollerQueue{
                QueueURL:          deps.DummyMessagesQueueURL,
                Handler:           awsapi.NewRawMessageHandler(deps.Commands.ProcessMessage),
                VisibilityTimeout: deps.DummyMessagesQueueVisibilityTimeoutSec,
        })

        return poller.Start(queuesCtx)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package awsapi

import (
        "context"
        "fmt"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "go.uber.org/dig"
)

//go:generate mockery --name=MessageSender --filename=mock_message_sender.go --config ../../../.mockery-funcs.yaml

type AWSConfigDeps struct {
        dig.In `ignore-unexported:"true"`

        Region       string `name:"config.aws.region"`
        BaseEndpoint string `name:"config.aws.baseEndpoint" optional:"true"`

        loadOpts []func(*config.LoadOptions) error
}

func newAWSConfigFactory(ctx context.Context) func(deps AWSConfigDeps) (aws.Config, error) <span class="cov10" title="6">{
        return func(deps AWSConfigDeps) (aws.Config, error) </span><span class="cov10" title="6">{
                opts := append([]func(*config.LoadOptions) error{
                        config.WithRegion(deps.Region),
                }, deps.loadOpts...)
                // BaseEndpoint is defined for local/test modes only and points on localstack instance
                if deps.BaseEndpoint != "" </span><span class="cov9" title="5">{
                        opts = append(opts,
                                config.WithBaseEndpoint(deps.BaseEndpoint),
                                config.WithCredentialsProvider(aws.AnonymousCredentials{}),
                        )
                }</span>
                <span class="cov10" title="6">cfg, err := config.LoadDefaultConfig(ctx, opts...)
                if err != nil </span><span class="cov1" title="1">{
                        return aws.Config{}, fmt.Errorf("failed to load aws configuration, %w", err)
                }</span>
                <span class="cov9" title="5">return cfg, nil</span>
        }
}

type MessageSender[TMessage any] func(
        ctx context.Context,
        message *TMessage,
) error
</pre>
		
		<pre class="file" id="file34" style="display: none">package awsapi

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/eventbridge"
        "github.com/aws/aws-sdk-go-v2/service/eventbridge/types"
        "go.uber.org/dig"
)

type EventBusMessageSenderDeps struct {
        dig.In

        EventBusName   string `name:"config.aws.eventBus.name"`
        EventBusSource string `name:"config.aws.eventBus.source"`

        RootLogger *slog.Logger
        Client     *eventbridge.Client
}

func NewEventBusMessageSender[TMessage any](detailType string, deps EventBusMessageSenderDeps) MessageSender[TMessage] <span class="cov10" title="3">{
        logger := deps.RootLogger.WithGroup("services.event-bus-message-sender")
        return func(ctx context.Context, message *TMessage) error </span><span class="cov6" title="2">{
                detail, err := json.Marshal(message)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal message, %w", err)
                }</span>
                <span class="cov6" title="2">res, err := deps.Client.PutEvents(ctx, &amp;eventbridge.PutEventsInput{
                        Entries: []types.PutEventsRequestEntry{
                                {
                                        EventBusName: &amp;deps.EventBusName,
                                        Source:       &amp;deps.EventBusSource,
                                        DetailType:   &amp;detailType,
                                        Detail:       aws.String(string(detail)),
                                },
                        },
                })
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed send message to event bus, %w", err)
                }</span>
                <span class="cov1" title="1">logger.DebugContext(ctx, "PutEvents response", slog.Any("response", res))
                logger.InfoContext(ctx, "Message sent",
                        slog.String("eventBusName", deps.EventBusName),
                        slog.String("eventBusSource", deps.EventBusSource),
                        slog.String("messageId", "n/a"), // TODO
                )
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by mockery v2.50.0. DO NOT EDIT.

//go:build !release

package awsapi

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockMessageSender is an autogenerated mock type for the MessageSender type
type MockMessageSender[TMessage interface{}] struct {
        mock.Mock
}

type MockMessageSender_Expecter[TMessage interface{}] struct {
        mock *mock.Mock
}

func (_m *MockMessageSender[TMessage]) EXPECT() *MockMessageSender_Expecter[TMessage] <span class="cov5" title="3">{
        return &amp;MockMessageSender_Expecter[TMessage]{mock: &amp;_m.Mock}
}</span>

// Execute provides a mock function with given fields: ctx, message
func (_m *MockMessageSender[TMessage]) Execute(ctx context.Context, message *TMessage) error <span class="cov5" title="3">{
        ret := _m.Called(ctx, message)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Execute")</span>
        }

        <span class="cov5" title="3">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *TMessage) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, message)
        }</span> else<span class="cov5" title="3"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov5" title="3">return r0</span>
}

// MockMessageSender_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockMessageSender_Execute_Call[TMessage interface{}] struct {
        *mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - message *TMessage
func (_e *MockMessageSender_Expecter[TMessage]) Execute(ctx interface{}, message interface{}) *MockMessageSender_Execute_Call[TMessage] <span class="cov5" title="3">{
        return &amp;MockMessageSender_Execute_Call[TMessage]{Call: _e.mock.On("Execute", ctx, message)}
}</span>

func (_c *MockMessageSender_Execute_Call[TMessage]) Run(run func(ctx context.Context, message *TMessage)) *MockMessageSender_Execute_Call[TMessage] <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*TMessage))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockMessageSender_Execute_Call[TMessage]) Return(_a0 error) *MockMessageSender_Execute_Call[TMessage] <span class="cov5" title="3">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockMessageSender_Execute_Call[TMessage]) RunAndReturn(run func(context.Context, *TMessage) error) *MockMessageSender_Execute_Call[TMessage] <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockMessageSender creates a new instance of MockMessageSender. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMessageSender[TMessage interface{}](t interface {
        mock.TestingT
        Cleanup(func())
}) *MockMessageSender[TMessage] <span class="cov10" title="10">{
        mock := &amp;MockMessageSender[TMessage]{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="10">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="10">return mock</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package awsapi

import (
        "context"

        "github.com/aws/aws-sdk-go-v2/service/eventbridge"
        "github.com/aws/aws-sdk-go-v2/service/sns"
        "github.com/aws/aws-sdk-go-v2/service/sqs"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/di"
        "go.uber.org/dig"
)

func Register(rootCtx context.Context, container *dig.Container) error <span class="cov8" title="1">{
        return di.ProvideAll(container,
                newAWSConfigFactory(rootCtx),
                sqs.NewFromConfig,
                sns.NewFromConfig,
                eventbridge.NewFromConfig,
                NewMessagesPoller,
        )
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package awsapi

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sns"
        "go.uber.org/dig"
)

type SNSMessageSenderDeps struct {
        dig.In

        RootLogger *slog.Logger
        SnsClient  *sns.Client
}

func NewSNSMessageSender[TMessage any](topicARN string, deps SNSMessageSenderDeps) MessageSender[TMessage] <span class="cov10" title="4">{
        logger := deps.RootLogger.WithGroup("services.sns-message-sender")
        return func(ctx context.Context, message *TMessage) error </span><span class="cov8" title="3">{
                body, err := json.Marshal(message)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal message, %w", err)
                }</span>
                <span class="cov8" title="3">res, err := deps.SnsClient.Publish(ctx, &amp;sns.PublishInput{
                        Message:  aws.String(string(body)),
                        TopicArn: aws.String(topicARN),
                })
                if err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed send message to sqs queue, %w", err)
                }</span>
                <span class="cov5" title="2">logger.InfoContext(ctx, "Message sent",
                        slog.String("topicARN", topicARN),
                        slog.String("messageId", *res.MessageId),
                )
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package awsapi

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "math"
        "runtime"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sqs"
        "github.com/aws/aws-sdk-go-v2/service/sqs/types"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/diag"
        "github.com/gofrs/uuid/v5"
        "go.uber.org/dig"
        "golang.org/x/sync/errgroup"
)

type RawMessageHandler func(ctx context.Context, rawMessage types.Message) error

func NewRawMessageHandler[TMessage any](
        handler func(ctx context.Context, msg *TMessage) error,
) RawMessageHandler <span class="cov6" title="5">{
        return func(ctx context.Context, rawMessage types.Message) error </span><span class="cov4" title="3">{
                var message TMessage
                if err := json.Unmarshal([]byte(*rawMessage.Body), &amp;message); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to unmarshal message, %w", err)
                }</span>
                <span class="cov3" title="2">return handler(ctx, &amp;message)</span>
        }
}

type MessagesPollerQueue struct {
        QueueURL string
        Handler  RawMessageHandler

        // The duration (in seconds) that the received messages are hidden
        // from subsequent retrieve requests after being retrieved
        // by a ReceiveMessage request.
        VisibilityTimeout int32
}

type MessagesPollerDeps struct {
        dig.In

        // config
        MaxPollWaitTimeSec int32 `name:"config.aws.sqs.maxPollWaitTimeSec"`

        RootLogger *slog.Logger
        SqsClient  *sqs.Client
}

type MessagesPoller struct {
        queues               []MessagesPollerQueue
        deps                 MessagesPollerDeps
        maxProcessingWorkers int32
        logger               *slog.Logger
}

func NewMessagesPoller(deps MessagesPollerDeps) *MessagesPoller <span class="cov4" title="3">{
        return &amp;MessagesPoller{
                deps:                 deps,
                maxProcessingWorkers: int32(math.Min(math.MaxInt32, float64(runtime.NumCPU()))),
                logger:               deps.RootLogger.WithGroup("services.messages-poller"),
        }
}</span>

func (p *MessagesPoller) RegisterQueue(queue MessagesPollerQueue) <span class="cov3" title="2">{
        p.queues = append(p.queues, queue)
}</span>

func (p *MessagesPoller) wrapRawMessageHandlerWithDeleteOnSuccess(
        queueURL string,
        handler RawMessageHandler,
) RawMessageHandler <span class="cov3" title="2">{
        return func(ctx context.Context, rawMessage types.Message) error </span><span class="cov1" title="1">{
                err := handler(ctx, rawMessage)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to handle message with target handler: %w", err)
                }</span>
                <span class="cov1" title="1">if _, err = p.deps.SqsClient.DeleteMessage(ctx, &amp;sqs.DeleteMessageInput{
                        QueueUrl:      aws.String(queueURL),
                        ReceiptHandle: rawMessage.ReceiptHandle,
                }); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to acknowledge message, %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

type processingData struct {
        rawMessage types.Message
        handler    RawMessageHandler
}

func (p *MessagesPoller) startProcessingWorkers(
        ctx context.Context,
) []chan processingData <span class="cov3" title="2">{
        processingWorkerChannels := make([]chan processingData, len(p.queues))
        for i := range processingWorkerChannels </span><span class="cov3" title="2">{
                processingWorkerChannels[i] = make(chan processingData)
                go func(ch &lt;-chan processingData) </span><span class="cov3" title="2">{
                        for data := range ch </span><span class="cov1" title="1">{
                                handlerCtx := diag.SetLogAttributesToContext(ctx, diag.LogAttributes{
                                        CorrelationID: slog.StringValue(uuid.Must(uuid.NewV4()).String()),
                                })
                                messageID := *data.rawMessage.MessageId
                                if err := data.handler(handlerCtx, data.rawMessage); err != nil </span><span class="cov1" title="1">{
                                        p.logger.ErrorContext(ctx,
                                                "Failed to process message",
                                                diag.ErrAttr(err),
                                                slog.String("messageID", messageID),
                                                slog.Any("messageAttributes", data.rawMessage.MessageAttributes),
                                                slog.Any("systemAttributes", data.rawMessage.Attributes),
                                        )
                                }</span> else<span class="cov0" title="0"> {
                                        p.logger.InfoContext(ctx,
                                                "Message processed",
                                                slog.String("messageID", messageID),
                                                slog.Any("messageAttributes", data.rawMessage.MessageAttributes),
                                                slog.Any("systemAttributes", data.rawMessage.Attributes),
                                        )
                                }</span>
                        }
                }(processingWorkerChannels[i])
        }
        <span class="cov3" title="2">return processingWorkerChannels</span>
}

// Returns true if polling should be continued
// otherwise returns false and error if polling should be stopped.
func (p *MessagesPoller) handleReceiveError(
        queueURL string,
        err error,
) (bool, error) <span class="cov10" title="15">{
        if err == nil </span><span class="cov9" title="13">{
                return true, nil
        }</span>
        <span class="cov3" title="2">if errors.Is(err, context.Canceled) </span><span class="cov3" title="2">{
                return false, nil
        }</span>
        // TODO: Retry logic can be added here
        <span class="cov0" title="0">return false, fmt.Errorf("failed to receive messages from queue %s: %w", queueURL, err)</span>
}

func (p *MessagesPoller) Start(ctx context.Context) error <span class="cov3" title="2">{
        p.logger.InfoContext(ctx, "Starting messages poller",
                slog.Int("queues", len(p.queues)),
                slog.Int64("maxProcessingWorkers", int64(p.maxProcessingWorkers)),
        )
        processingWorkerChannels := p.startProcessingWorkers(ctx)

        grp := errgroup.Group{}

        for _, queue := range p.queues </span><span class="cov3" title="2">{
                handler := p.wrapRawMessageHandlerWithDeleteOnSuccess(
                        queue.QueueURL,
                        queue.Handler,
                )
                grp.Go(func() error </span><span class="cov3" title="2">{
                        p.logger.DebugContext(ctx,
                                "Polling messages from queue",
                                slog.String("queueURL", queue.QueueURL),
                                slog.String("visibilityTimeout", fmt.Sprintf("%ds", queue.VisibilityTimeout)),
                                slog.Int64("pollWaitTimeSec", int64(p.deps.MaxPollWaitTimeSec)),
                        )
                        for </span><span class="cov10" title="15">{
                                gotMessages, err := p.deps.SqsClient.ReceiveMessage(ctx, &amp;sqs.ReceiveMessageInput{
                                        QueueUrl:                    &amp;queue.QueueURL,
                                        MaxNumberOfMessages:         p.maxProcessingWorkers,
                                        WaitTimeSeconds:             p.deps.MaxPollWaitTimeSec,
                                        VisibilityTimeout:           queue.VisibilityTimeout,
                                        MessageAttributeNames:       []string{"All"},
                                        MessageSystemAttributeNames: []types.MessageSystemAttributeName{"All"},
                                })
                                var shouldContinue bool
                                if shouldContinue, err = p.handleReceiveError(queue.QueueURL, err); !shouldContinue </span><span class="cov3" title="2">{
                                        return err
                                }</span>
                                <span class="cov9" title="13">p.logger.DebugContext(ctx,
                                        "Processing queue messages",
                                        slog.String("queueURL", queue.QueueURL),
                                        slog.Int("messagesCount", len(gotMessages.Messages)),
                                        slog.Any("resultMetadata", gotMessages.ResultMetadata),
                                )
                                for _, rawMessage := range gotMessages.Messages </span><span class="cov1" title="1">{
                                        for _, ch := range processingWorkerChannels </span><span class="cov1" title="1">{
                                                ch &lt;- processingData{
                                                        rawMessage: rawMessage,
                                                        handler:    handler,
                                                }
                                        }</span>
                                }
                        }
                })
        }

        <span class="cov3" title="2">return grp.Wait()</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package services

import (
        "context"
        "errors"
        "time"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/di"
        "github.com/gemyago/aws-messaging-boilerplate-go/internal/services/awsapi"
        "go.uber.org/dig"
)

func Register(rootCtx context.Context, container *dig.Container) error <span class="cov8" title="1">{
        return errors.Join(
                awsapi.Register(rootCtx, container),
                di.ProvideAll(container,
                        NewTimeProvider,
                        di.ProvideValue(time.NewTicker),
                        NewShutdownHooks,
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// ShutdownHooks are used to implement a graceful shutdown
// of the application. This may include closing database connections, flushing pending
// events to the queue, shutting down the http server, etc.

package services

import (
        "context"
        "fmt"
        "log/slog"
        "reflect"
        "time"

        "go.uber.org/dig"
        "golang.org/x/sync/errgroup"
)

type shutdownHook struct {
        name       string
        shutdownFn func(ctx context.Context) error
}

type ShutdownHooks struct {
        logger *slog.Logger
        hooks  []shutdownHook
        deps   ShutdownHooksRegistryDeps
}

// HasHook checks if a shutdown hook with the given name is registered.
// Typical usage is in tests and must be carefully considered for production scenarios.
func (h *ShutdownHooks) HasHook(name string, method any) bool <span class="cov5" title="4">{
        for _, hook := range h.hooks </span><span class="cov4" title="3">{
                if hook.name == name </span><span class="cov3" title="2">{
                        return reflect.ValueOf(hook.shutdownFn).Pointer() == reflect.ValueOf(method).Pointer()
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}

func (h *ShutdownHooks) Register(name string, shutdown func(ctx context.Context) error) <span class="cov10" title="13">{
        h.hooks = append(h.hooks, shutdownHook{name: name, shutdownFn: shutdown})
}</span>

func (h *ShutdownHooks) RegisterNoCtx(name string, shutdown func() error) <span class="cov5" title="4">{
        h.Register(name, func(_ context.Context) error </span><span class="cov5" title="4">{
                return shutdown()
        }</span>)
}

func (h *ShutdownHooks) PerformShutdown(ctx context.Context) error <span class="cov6" title="5">{
        ctx, cancel := context.WithTimeout(ctx, h.deps.GracefulShutdownTimeout)
        defer cancel()

        errGrp := errgroup.Group{}
        for _, hook := range h.hooks </span><span class="cov9" title="11">{
                errGrp.Go(func() error </span><span class="cov9" title="11">{
                        hookName := hook.name
                        h.logger.InfoContext(ctx, fmt.Sprintf("Shutting down %s", hookName))
                        if err := hook.shutdownFn(ctx); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to perform shutdown hook %s: %w", hookName, err)
                        }</span>
                        <span class="cov9" title="10">return nil</span>
                })
        }

        <span class="cov6" title="5">done := make(chan error)
        go func() </span><span class="cov6" title="5">{
                done &lt;- errGrp.Wait()
        }</span>()

        <span class="cov6" title="5">select </span>{
        case err := &lt;-done:<span class="cov6" title="5">
                return err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

type ShutdownHooksRegistryDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        GracefulShutdownTimeout time.Duration `name:"config.gracefulShutdownTimeout"`
}

func NewShutdownHooks(deps ShutdownHooksRegistryDeps) *ShutdownHooks <span class="cov7" title="7">{
        return &amp;ShutdownHooks{
                logger: deps.RootLogger.WithGroup("shutdown"),
                deps:   deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">//go:build !release

package services

import (
        "time"

        "github.com/gemyago/aws-messaging-boilerplate-go/internal/diag"
        "github.com/go-faker/faker/v4"
)

type MockNow struct {
        value time.Time
}

var _ TimeProvider = &amp;MockNow{}

func (m *MockNow) SetValue(t time.Time) <span class="cov0" title="0">{
        m.value = t
}</span>

func (m *MockNow) Now() time.Time <span class="cov0" title="0">{
        return m.value
}</span>

func NewMockNow() *MockNow <span class="cov0" title="0">{
        return &amp;MockNow{
                value: time.UnixMilli(faker.RandomUnixTime()),
        }
}</span>

func MockNowValue(p TimeProvider) time.Time <span class="cov0" title="0">{
        mp, ok := p.(*MockNow)
        if !ok </span><span class="cov0" title="0">{
                panic("provided TimeProvider is not a MockNow")</span>
        }
        <span class="cov0" title="0">return mp.value</span>
}

const defaultTestShutdownTimeout = 30 * time.Second

func NewTestShutdownHooks() *ShutdownHooks <span class="cov10" title="2">{
        return NewShutdownHooks(ShutdownHooksRegistryDeps{
                RootLogger:              diag.RootTestLogger(),
                GracefulShutdownTimeout: defaultTestShutdownTimeout,
        })
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package services

import "time"

type TimeProvider interface {
        Now() time.Time
}

type timeProviderFn func() time.Time

func (fn timeProviderFn) Now() time.Time <span class="cov8" title="1">{
        return fn()
}</span>

func NewTimeProvider() TimeProvider <span class="cov8" title="1">{
        return timeProviderFn(time.Now)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
